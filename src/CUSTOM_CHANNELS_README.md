# Реализация отправки кастомных данных на каналы 10-15

## Описание функционала

Реализован модуль для отправки пользовательских текстовых данных на зарезервированные каналы 10-15 (и 16) ExpressLRS через CRSF протокол с интервалом 5 секунд.

## Отправляемые данные

На каждые 5 секунд система отправляет следующие данные:

```
Канал 10: "MY"
Канал 11: "NAME"
Канал 12: "IS"
Канал 13: "ARTEM"
Канал 14: "I"
Канал 15: "AM"
Канал 16: "UKRAINIAN"
```

## Структура CRSF значений

Каждый текст кодируется в 11-битное значение CRSF:
- **Диапазон**: 0-2047
- **Нейтральное значение**: 992 (соответствует 1500 µs)
- **Минимальное значение**: 191 (соответствует 988 µs)
- **Максимальное значение**: 1791 (соответствует 2012 µs)

### Алгоритм кодирования

1. Для каждой текстовой строки вычисляется усредненное ASCII значение всех символов
2. Это значение масштабируется в диапазон CRSF по формуле:
   ```
   CRSF_value = NEUTRAL + ((ASCII_value - 79) * 7)
   ```
3. Результат обрезается до диапазона [0, 2047]

## Реализованные компоненты

### 1. `include/CustomChannelData.h`

Заголовочный файл с определением класса `CustomChannelData`:

```cpp
class CustomChannelData {
public:
    static void init();                              // Инициализация
    static bool update(uint32_t now);               // Проверка интервала
    static void applyToChannels(uint32_t *data);   // Применение данных
private:
    static constexpr uint32_t INTERVAL_MS = 5000;  // 5 секунд
    static constexpr uint8_t START_CHANNEL = 10;
    ...
};
```

### 2. `src/CustomChannelData.cpp`

Реализация класса с функциями:
- `init()` - инициализирует переменные и выводит сообщение в лог
- `update(uint32_t now)` - проверяет прошло ли 5 секунд, возвращает true/false
- `applyToChannels()` - кодирует текст и устанавливает значения на каналы 10-15
- `charToCRSFValue()` - кодирует один символ
- `textToCRSFValue()` - кодирует текстовую строку

### 3. Интеграция в `src/tx_main.cpp`

Добавлены три ключевых изменения:

1. **Включение заголовка** (строка ~4):
   ```cpp
   #include "CustomChannelData.h"
   ```

2. **Инициализация в setup()** (строка ~1504):
   ```cpp
   devicesStart();
   // Инициализируем модуль кастомных данных каналов
   CustomChannelData::init();
   ```

3. **Применение данных перед отправкой пакета** (строка ~607):
   ```cpp
   // Применяем кастомные данные к каналам 10-15 каждые 5 секунд
   if (CustomChannelData::update(now))
   {
       CustomChannelData::applyToChannels(ChannelData);
   }
   OtaPackChannelData(&otaPkt, ChannelData, ...);
   ```

## Поток выполнения

1. **Инициализация** → В setup() вызывается `CustomChannelData::init()`
2. **Основной цикл** → В loop() каждый раз проверяется `CustomChannelData::update(now)`
3. **Каждые 5 секунд** → Вызывается `CustomChannelData::applyToChannels(ChannelData)`
4. **Отправка пакета** → Каналы с данными отправляются через `OtaPackChannelData()`
5. **Прием на приемнике** → Приемник получит текстовые данные на каналах 10-15

## Логирование

Система выводит отладочную информацию в лог:
- При инициализации модуля
- При применении данных (каждые 5 секунд)
- Значения каждого канала в формате: `CH10='MY' -> value=...`

## Тестирование

Создан файл `test_custom_channel_data.cpp` для проверки:
- Кодирования текста в CRSF значения
- Корректности диапазона значений (0-2047)
- Механизма отсчета времени (5 секунд)

## Использование на приемнике

На приемнике (RX) можно читать текстовые данные из каналов 10-15:

```cpp
// В RX коде можно добавить:
if (ChannelData[10] != prevCH10) {
    // Декодировать значение обратно в текст
    // и использовать для логики
}
```

## Примечания

- Каналы 0-9 остаются для стандартных управляющих сигналов
- Каналы 10-15 теперь зарезервированы для пользовательских данных
- Механизм полностью неинвазивен - не нарушает стандартное функционирование
- Все вычисления происходят только раз в 5 секунд для экономии ресурсов
- Кодирование детерминировано - один текст всегда кодируется одинаково
