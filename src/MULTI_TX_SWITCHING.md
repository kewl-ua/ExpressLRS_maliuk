# Функционал переключения между несколькими TX

## Описание

Эта функция позволяет одному RX (приемнику) **автоматически переключаться между несколькими TX (передатчиками) с РАЗНЫМИ bind фразами (UID)**, отслеживать RSSI для каждого из них и отображать информацию на OLED дисплее.

## ⚠️ ВАЖНО: Настройка UID

Перед использованием **ОБЯЗАТЕЛЬНО** замените UID в массиве `TX_UIDS` в файле [rx_main.cpp](src/rx_main.cpp) на реальные UID ваших передатчиков:

```cpp
const uint8_t TX_UIDS[MAX_TX_COUNT][UID_LEN] = {
    {0x00, 0x00, 0x11, 0x22, 0x33, 0x44},  // TX1 - ЗАМЕНИТЕ!
    {0x00, 0x00, 0x55, 0x66, 0x77, 0x88},  // TX2 - ЗАМЕНИТЕ!
    {0x00, 0x00, 0x99, 0xAA, 0xBB, 0xCC}   // TX3 - ЗАМЕНИТЕ!
};
```

### Как получить UID вашего TX:
1. Подключитесь к TX через веб-интерфейс WiFi
2. Зайдите в раздел Options или настройки
3. Найдите "Binding Phrase" или UID
4. Скопируйте 6 байт UID в формате hex

## Как это работает

### 1. Структура данных для TX

В файле `rx_main.cpp` добавлена структура `TxInfo`:
```cpp
struct TxInfo {
    int16_t rssi_1;      // RSSI от антенны 1
    int16_t rssi_2;      // RSSI от антенны 2
    uint32_t lastSeen;   // Время последнего пакета от этого TX
    bool active;         // Активен ли этот TX
};
```

### 2. Буфер для хранения информации о TX

Создается массив `txArray[MAX_TX_COUNT]` (по умолчанию 3 TX):
```cpp
TxInfo txArray[MAX_TX_COUNT];
uint8_t currentTxIndex = 0;          // Текущий активный TX (0-2)
uint32_t txSwitchInterval = 5000;    // Переключение каждые 5 секунд
uint32_t lastTxSwitchTime = 0;
```

### 3. Хранение UID для каждого TX

В [rx_main.cpp](src/rx_main.cpp) создан массив UID:
```cpp
const uint8_t TX_UIDS[MAX_TX_COUNT][UID_LEN] = {
    {0x00, 0x00, 0x11, 0x22, 0x33, 0x44},  // TX1
    {0x00, 0x00, 0x55, 0x66, 0x77, 0x88},  // TX2
    {0x00, 0x00, 0x99, 0xAA, 0xBB, 0xCC}   // TX3
};
```

### 4. Обновление RSSI

В функции `getRFlinkInfo()` добавлен код для сохранения RSSI текущего TX:
```cpp
// Update TX info for multi-TX tracking
if (currentTxIndex < MAX_TX_COUNT) {
    txArray[currentTxIndex].rssi_1 = linkStats.uplink_RSSI_1;
    txArray[currentTxIndex].rssi_2 = linkStats.uplink_RSSI_2;
    txArray[currentTxIndex].lastSeen = millis();
    txArray[currentTxIndex].active = true;
}
```

### 5. Логика переключения между TX с ресинхронизацией

В основном цикле `loop()` реализовано **настоящее** переключение между TX:

```cpp
// Проверяем, пора ли переключаться
if (now - lastTxSwitchTime > txSwitchInterval) {
    needToSwitchTx = true;
    lastTxSwitchTime = now;
}

// Переключение происходит только когда RX в disconnected состоянии
if (needToSwitchTx && connectionState == disconnected) {
    // Переходим к следующему TX
    currentTxIndex = (currentTxIndex + 1) % MAX_TX_COUNT;
    
    // Загружаем новый UID
    memcpy(UID, TX_UIDS[currentTxIndex], UID_LEN);
    
    // Обновляем конфигурацию для нового UID
    config.SetUID(UID);
    OtaUpdateCrcInitFromUid();
    FHSSrandomiseFHSSsequence(uidMacSeedGet());
    
    needToSwitchTx = false;
}

// Если нужно переключиться, но мы подключены - сначала отключаемся
if (needToSwitchTx && connectionState == connected) {
    LostConnection(true);  // Триггерим потерю соединения
}
```

**Как это работает:**
1. Каждые 5 секунд устанавливается флаг `needToSwitchTx`
2. Если RX подключен к TX - вызывается `LostConnection()` для разрыва связи
3. Когда RX переходит в состояние `disconnected`, происходит:
   - Смена индекса TX
   - Загрузка нового UID из массива
   - Обновление FHSS и CRC для нового UID
   - Автоматический поиск TX с новым UID
4. RX синхронизируется с новым TX и сохраняет его RSSI

### 6. Отображение на OLED дисплее

Файл [rx_oled_simple.h](src/rx_oled_simple.h) обновлен для отображения информации о всех TX:

**В подключенном состоянии:**
```
Connected to TX2
TX1: -75 dBm
TX2: -82 dBm
TX3: ---
LQ:100 SNR:8
```

**В отключенном состоянии:**
```
UID:556677889900
Searching...
Last TX: 2
BIND: OFF
```

## Настройка параметров

### Изменение количества TX

В файле `rx_main.cpp` измените константу:
```cpp
#define MAX_TX_COUNT 3  // Измените на нужное количество
```

### Изменение интервала переключения

В файле `rx_main.cpp` измените переменную:
```cpp
uint32_t txSwitchInterval = 5000;  // Время в миллисекундах (5000 = 5 сек)
```

## Прошивка устройств

### Шаг 1: Настройка TX

Каждый TX должен иметь **СВОЮ УНИКАЛЬНУЮ bind фразу (UID)**:

1. **TX1:** Прошейте с bind фразой #1 (например, "MyDrone_TX1")
2. **TX2:** Прошейте с bind фразой #2 (например, "MyDrone_TX2")
3. **TX3:** Прошейте с bind фразой #3 (например, "MyDrone_TX3")

### Шаг 2: Получение UID каждого TX

Для каждого TX:
1. Включите TX в режиме WiFi
2. Подключитесь к его веб-интерфейсу
3. Найдите UID (6 байт в hex формате, например: `00 00 11 22 33 44`)
4. Запишите UID

### Шаг 3: Настройка RX

1. Откройте файл [rx_main.cpp](src/rx_main.cpp)
2. Найдите массив `TX_UIDS` (примерно строка 105)
3. Замените значения на **реальные UID** ваших TX:
   ```cpp
   const uint8_t TX_UIDS[MAX_TX_COUNT][UID_LEN] = {
       {0x00, 0x00, 0x11, 0x22, 0x33, 0x44},  // Замените на UID TX1
       {0x00, 0x00, 0x55, 0x66, 0x77, 0x88},  // Замените на UID TX2
       {0x00, 0x00, 0x99, 0xAA, 0xBB, 0xCC}   // Замените на UID TX3
   };
   ```

### Шаг 4: Компиляция и прошивка RX

1. Скомпилируйте прошивку для RX с измененным кодом
2. Прошейте RX
3. RX будет автоматически переключаться между TX каждые 5 секунд

## Как проверить работу

### Тест 1: Проверка переключения
1. Включите RX с подключенным OLED дисплеем
2. Включите TX1 - через несколько секунд на дисплее появится:
   ```
   Connected to TX1
   TX1: -75 dBm
   ```
3. Подождите ~5 секунд
4. RX отключится и начнет искать TX2
5. Включите TX2 - RX подключится к нему:
   ```
   Connected to TX2
   TX2: -68 dBm
   ```

### Тест 2: Мониторинг всех TX
1. Включите все 3 TX одновременно
2. RX будет циклически переключаться между ними
3. На дисплее вы увидите накопленные RSSI от всех TX:
   ```
   Connected to TX2
   TX1: -75 dBm
   TX2: -68 dBm
   TX3: -80 dBm
   LQ:100 SNR:8
   ```

### Что вы увидите в Serial Monitor (debug):
```
Switched to TX1, UID=(0,0,17,34,51,68)
lost conn fc=0 fo=0
got conn
Switched to TX2, UID=(0,0,85,102,119,136)
Disconnecting to switch TX...
lost conn fc=0 fo=0
got conn
```

## Расширенные возможности

### Добавление ручного переключения

Вы можете добавить кнопку для ручного переключения между TX:
```cpp
void manualSwitchTx() {
    currentTxIndex = (currentTxIndex + 1) % MAX_TX_COUNT;
    lastTxSwitchTime = millis();  // Reset timer
}
```

### Выбор TX с лучшим RSSI

Можно добавить автоматический выбор TX с наилучшим сигналом:
```cpp
uint8_t getBestTxIndex() {
    uint8_t bestIdx = 0;
    int16_t bestRssi = -200;  // Start with very low value
    
    for (uint8_t i = 0; i < MAX_TX_COUNT; i++) {
        if (txArray[i].active && txArray[i].rssi_1 > bestRssi) {
            bestRssi = txArray[i].rssi_1;
            bestIdx = i;
        }
    }
    
    return bestIdx;
}
```

## Возможные проблемы и решения

### Проблема: RX не подключается ни к одному TX
**Решение:** 
- Проверьте, что UID в массиве `TX_UIDS` **точно совпадают** с UID ваших TX
- Убедитесь, что TX включен и находится в радиусе действия
- Проверьте, что частота и настройки RX/TX совместимы

### Проблема: RSSI показывает "---" для некоторых TX
**Решение:** 
- Это **нормально**, если TX еще не был активен
- Подождите, пока RX переключится на этот TX (5 секунд на каждый)
- Если TX выключен, его RSSI останется "---"

### Проблема: RX постоянно переключается и не держит связь
**Решение:**
- Возможно, указан неправильный UID для одного из TX
- Проверьте все UID в массиве `TX_UIDS`
- Временно увеличьте `txSwitchInterval` до 10000-15000 мс для тестирования

### Проблема: Дисплей не показывает информацию
**Решение:** 
- Проверьте подключение I2C дисплея (SDA=21, SCL=22 для TTGO V2)
- Убедитесь, что библиотека U8g2 установлена
- Проверьте I2C адрес вашего дисплея

### Проблема: Компиляция не проходит
**Решение:**
- Убедитесь, что используете PlatformIO
- Проверьте, что все библиотеки установлены
- Ошибки IntelliSense можно игнорировать - важна реальная компиляция

## Принцип работы переключения

### Что происходит при переключении:

1. **Таймер срабатывает** (каждые 5 секунд)
2. **Устанавливается флаг** `needToSwitchTx = true`
3. **Если RX подключен** к TX:
   - Вызывается `LostConnection(true)` - принудительный разрыв связи
   - RX переходит в состояние `disconnected`
4. **Когда RX отключен:**
   - Переключение на следующий TX: `currentTxIndex = (currentTxIndex + 1) % 3`
   - Загрузка нового UID: `memcpy(UID, TX_UIDS[currentTxIndex], UID_LEN)`
   - Обновление FHSS: `FHSSrandomiseFHSSsequence(uidMacSeedGet())`
   - Обновление CRC: `OtaUpdateCrcInitFromUid()`
5. **RX начинает поиск** TX с новым UID
6. **При нахождении TX** - устанавливается связь и сохраняется RSSI

### Важные моменты:

- **Каждый TX имеет уникальный UID** - это обязательное требование
- **Переключение происходит только в disconnected состоянии** - это гарантирует чистую ресинхронизацию
- **RSSI накапливается** - после каждого подключения обновляется информация о TX
- **Время переключения ~5 секунд** + время синхронизации (обычно 1-2 секунды)

## Примечания

- Текущая реализация переключает TX циклически каждые 5 секунд
- RSSI сохраняется для каждого TX независимо
- Если TX выключен, RX будет пытаться подключиться к нему, но перейдет к следующему через timeout
- Вы можете модифицировать логику переключения для своих нужд (например, автовыбор TX с лучшим сигналом)

## Файлы, которые были изменены

1. [src/rx_main.cpp](src/rx_main.cpp):
   - Добавлена структура `TxInfo` для хранения данных о TX
   - Создан массив `TX_UIDS[3][6]` с UID каждого TX (ТРЕБУЕТ НАСТРОЙКИ!)
   - Реализована логика переключения с ресинхронизацией
   - Добавлено сохранение RSSI для текущего TX

2. [src/rx_oled_simple.h](src/rx_oled_simple.h):
   - Обновлен метод `update()` для отображения всех TX
   - Добавлено отображение текущего активного TX
   - Показываются RSSI всех TX (даже неактивных)
